def solve_n_queens(n):
    """
    حل مسئله N وزیر (N-Queens Problem)
    هدف: قرار دادن n وزیر روی صفحه شطرنج n×n به طوری که هیچ دو وزیری یکدیگر را تهدید نکنند
    (یعنی در یک ردیف، ستون یا قطر نباشند)
    """
    board = [[0] * n for _ in range(n)]  # صفحه خالی (0 به معنای بدون وزیر)
    solutions = []                       # لیست برای ذخیره تمام جواب‌ها
    
    def is_safe(row, col):
        """بررسی اینکه آیا می‌توان وزیر را در موقعیت (row, col) قرار داد؟"""
        
        # بررسی ستون بالا
        for i in range(row):
            if board[i][col] == 1:
                return False
        
        # بررسی قطر چپ-بالا
        for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):
            if board[i][j] == 1:
                return False
        
        # بررسی قطر راست-بالا
        for i, j in zip(range(row-1, -1, -1), range(col+1, n)):
            if board[i][j] == 1:
                return False
        
        return True
    
    def backtrack(row):
        """الگوریتم بازگشت به عقب برای قرار دادن وزیرها ردیف به ردیف"""
        if row == n:  # همه وزیرها قرار گرفتند
            solutions.append([row[:] for row in board])  # یک کپی از صفحه اضافه کن
            return
        
        for col in range(n):  # هر ستون در ردیف فعلی را امتحان کن
            if is_safe(row, col):
                board[row][col] = 1          # وزیر را قرار بده
                backtrack(row + 1)           # به ردیف بعدی برو
                board[row][col] = 0          # بازگشت به عقب (backtrack)
    
    backtrack(0)  # شروع از ردیف اول
    
    return solutions

def print_solution(board):
    """چاپ زیبا یک جواب (Q به معنای وزیر، . به معنای خالی)"""
    n = len(board)
    for i in range(n):
        for j in range(n):
            if board[i][j] == 1:
                print(" Q ", end="")
            else:
                print(" . ", end="")
        print()
    print("\n")

# مثال: حل مسئله برای n = 8 (شطرنج استاندارد)
n = 8
solutions = solve_n_queens(n)

print(f"تعداد جواب‌های مسئله {n} وزیر: {len(solutions)}")
print("یکی از جواب‌ها:")
if solutions:
    print_solution(solutions[0])
else:
    print("هیچ جوابی وجود ندارد!")

"""
ایده اصلی الگوریتم (Backtracking برای N-Queens):

1. مسئله را ردیف به ردیف حل می‌کنیم (از ردیف ۰ شروع می‌شود).
2. برای هر ردیف، تمام ستون‌ها (۰ تا n-۱) را یکی یکی امتحان می‌کنیم.
3. قبل از قرار دادن وزیر در موقعیت (row, col)، با تابع is_safe بررسی می‌کنیم که:
   - هیچ وزیری در همان ستون در ردیف‌های قبلی نباشد.
   - هیچ وزیری در قطر چپ-بالا نباشد.
   - هیچ وزیری در قطر راست-بالا نباشد.
   (قطرهای پایین نیازی به بررسی ندارند چون هنوز ردیف‌های پایین پر نشده‌اند.)
4. اگر موقعیت امن بود، وزیر را قرار می‌دهیم و به طور بازگشتی به ردیف بعدی می‌رویم.
5. اگر به ردیف n رسیدیم، یعنی یک جواب کامل پیدا شده و آن را ذخیره می‌کنیم.
6. اگر در مسیری به بن‌بست رسیدیم، وزیر آخر را برمی‌داریم (backtrack) و ستون بعدی را امتحان می‌کنیم.
7. این فرآیند تمام ترکیب‌های ممکن را بررسی می‌کند و همه جواب‌های معتبر را پیدا می‌کند.

این روش برای n≤۱۲ بسیار سریع عمل می‌کند. برای n بزرگ‌تر می‌توان از بهینه‌سازی‌های اضافی (مثل بیت‌مسک) استفاده کرد.
"""